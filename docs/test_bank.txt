#L001 W1
Урезанная форма языка программирования, созданная 
специально для решения определенного вида проблем:
$?  Lisp
$!  язык предметной области
$?  языковой инструментарий
$?  yacc

#L002 W1
Язык предметной области это:
$?  Не тьюринг полный язык.
$!  Язык созданный для решения узкого класса проблем.
$?  Язык позволяющий не программистам писать программы.
$?  Язык имеющий абстрактный синтаксис.

#L003 W1
Общее название для такого стиля разработки программного 
обеспечения, который строится вокруг использования ряда 
языков, специфичных для данной предметной области. 
$?  объектно ориентированное программирование
$!  языкоориентированное программирование
$?  языковой инструментарий

#L004 W1
Общий термин для всех видов приложений, разработанных 
для поддержки языкоориентированного программирования.
$?  малые языки
$!  языковой инструментарий
$?  yacc
$?  Lisp

#L005 W1
Два языка предметной области:
$?  могут иметь общий абстрактный синтаксис 
$!  могут иметь общий конкретный синтаксис
$!  не могут иметь общий абстрактный синтаксис
$?  не могут иметь общий конкретный синтаксис

#L006 W1
Укажите языки предметной области:
$!  малые языки
$?  yacc
$!  конфигурационные файлы XML
$?  Lisp

#L007 W1
Конфигурационные файлы XML являются
$!  Являются внешним языком предметной области (DSL)
$?  Являются внутренним языки предметной области (DSL)
$?  Не являются языком предметной области (DSL)

#L008 W1
Создание внутренних языков предметной области (DSL) возможно с использованием
$!  Lisp
$!  Ruby
$?  XML
$?  Yacc

#L009 W1
Укажите преимущества внешних языков предметной области (DSL)
$!  Можно задавать произвольный синтаксис
$?  Существует хорошая интеграция с основным языком
$!  Код более удобен для чтения
$?  Существуют удобные инструменты для языка
$!  Не требует высокой квалификации

#L010 W1
Укажите преимущества внутренних языков предметной области (DSL)
$?  Можно задавать произвольный синтаксис
$!  Существует хорошая интеграция с основным языком
$?  Код более удобен для чтения
$!  Существуют удобные инструменты для языка
$?  Не требует высокой квалификации

#L011 W1
Укажите языки наиболее подходящие для создания внутренних (DSL)
$?  C
$?  C++
$?  Java
$?  C#
$!  Lisp
$!  Smalltalk 
$!  Ruby

#L012 W1
Укажите элементы языка полезные при создании DSL
$!  замыкания 
$!  макросы
$!  аннотации
$?  ООП
$?  типизация

#L013 W1
Укажите основные шаги создания новых DSL:
$!  Определить абстрактный синтаксис
$!  Выбрать редактор
$!  Создать генератор
$?  Определить ключевые слова языка
$?  Определить операторы языка
$?  Определить формат для хранениея программ

#L014 W1
Укажите базовые свойства языкового инструментария:
$!  Пользователи могут легко создавать новые языки
$!  Языки являются взаимноинтегрированными
$!  Главным источником информации является модель приложения
$?  Создание языка не требует описания абстрактоного синтаксиса

#L015 W1
Укажите базовые свойства языкового инструментария:
$!  Пользователи нового языка манипулируют им с помощью проекционного редактора
$!  Языковой инструментарий может работать, даже если абстрактная 
модель содержит неполную или противоречивую информацию
$?  Языковой инструментарий позволяет задавать языки графически

#L016 W1
Укажите составляющие нового DSL:
$!  схема
$!  редактор (редакторы)
$!  генератор (генераторы)
$?  модель (модели)
$?  проект

#L017 W1
Исходным представление программы для языкового инструментария является:
$?  текстовый файл
$!  абстрактное представление программы
$?  конкретный синтаксис
$?  конкретное представление программы

#L018 W1
Язык для представления конкретного синтаксиса языка в MPS называется:
$!  Язык редактора
$?  Язык структуры
$?  Язык конкретного синтаксиса
$?  Язык генератора

#L019 W1
Редактор MPS состоит из следующих частей.
!?  Ячеек
$?  Узлов
$?  Компонентов
$?  Элементов

#L020 W1
Для каждого концепта можно определить:
$?  Ровно один редактор
$!  Один или ни одного редактора
$?  Один или более редактор
$?  Любое количество редакторов

#L021 W1
Если для данного концепта не заданна структура редактора, 
то для узлов данного концепта.
$?  Структура редактора не будет определена
$?  Структура редактора будет браться из предка
$?  Структура редактора будет браться из интерфейса
$!  Структура редактора будет браться из предка или интерфейса

#L022 W1
Укажите название модели ячейки {name}
$!  Свойство
$?  Ребенок
$?  Ссылка
$?  Коллекция

#L023 W1
Укажите название модели ячейки %node%
$?  Свойство
$!  Ребенок
$?  Ссылка
$?  Коллекция

#L024 W1
Укажите название модели ячейки [-...-]
$?  Свойство
$?  Ребенок
$?  Ссылка
$!  Коллекция

#L023 W1
Какая из данных моделей ячеек используется, чтобы избежать дублирования?
$!  Ячейки компоненты редактора
$?  Ячейка список детей
$?  Ячейка список детей
$?  Константная ячейка

#L024 W1
Для расположения ячеек в виде текста используется:
$!  indent layout
$?  horizontal layout
$?  vertical layout
$?  flow layout

#L025 W1
Какое количество предков может иметь таблица стилей:
$!  Не более одного
$?  Любое количество
$?  Ни одного

#L026 W1
Для задания действий происходящих при нажатии клавиш требуется использовать:
$!  Key map
$?  Key handler
$?  Action map

#L027 W1
Key map определяется для:
$?  Узла
$?  Редактора
$!  Ячейки

#L028 W1
Action map определяется для:
$?  Узла
$?  Редактора
$!  Ячейки

#L029 W1
Action map может переопределять:
$!  удаление
$!  правое преобразование
$?  левое преобразование
$?  добавление узла

#L030 W1
Для предопределения поведения при нажатии Delete требуется задать
$?  Key Map
$!  Action Map
$?  Key handler

#L031 W1
Выделение находится внутри позиции, которая позволяет подстановку концепта A. 
Какие подконцепты A не будут включены в меню автодополнениея:
$?  концепты, для которых не определен редактор
$?  концепты, для которых метод canSubstitute возвращает false
$!  абстрактные концепты
$!  концепты, для которых 'can be a child' (может быть ребенком) возвращает false

#L032 W1
Часть языка, определяющая оперативную семантику концептов языка:
$!  Генератор
$?  Редактор
$?  Схема
$?  Модель

#L033 W1
Генерация кода в системе MPS происходит путем 
$!  трансформации моделей-в-модели
$?  трансформации моделей-в-текст
$?  трансформации текста-в-текст

#L034 W1
Генератор располагается 
$?  в отдельном руте
$?  в отдельной модели
$!  в отдельном модуле

#L035 W1
Трансформации при генерации определяются при помощи:
$!  правил генерации
$?  правил трансформации
$?  методов генерации

#L036 W1
Каждое правило генерации может содержать
$!  предпосылки
$!  следствие
$!  условие применимости
$?  название правила

#L037 W1
Макросы в шаблонах генерации реализованы при помощи:
$!  Аннотаций
$?  Ссылок
$?  Методов
$?  Концептов

#L038 W1
Существуют следующие виды макросов:
$!  макросы свойств
$!  макросы ссылок
$!  макросы узлов
$?  макросы концептов
$?  макросы корневых узлов

#L039 W1
В системе MPS служить типом может:
$!  любой узел
$?  любой объект
$?  узел концепта Type
$?  объект класса Type

#L040 W1
Конструкция typeof
$?  возвращает Тип узла
$!  возвращает Типовою переменную соответствующую узлу
$?  проверяет соответствие типа

#L041 W1
Конструкция when concrete может использоваться
$?  где угодно
!?  в правилах вывода типов
!?  в методах помеченных специальной аннотацией

#L042 W1
Сильная подтиповость требуется для:
$!  вызова методов объекта
$!  доступа к полям объекта
$?  присваивания объекта
$?  передачи объекта в качестве параметра

#L043 W1
Тип n является слабым подтипом Integer укажите возможные конструкции

$?  n.toString();

$!  Object obj = n;

$!  method(n); // где метод принимает тип Object

#L044 W1
Выражение typeof(expr1) :==: typeof(expr2) означает:
$!  Тип expr1 равен типу expr2
$?  Тип expr1 сравним с типом expr2
$?  Либо expr1 является надтипом expr2, либо expr2 является надтипом expr1.

#L045 W1
Выражение typeof(expr1) :~: typeof(expr2) означает:
$?  Тип expr1 равен типу expr2
$!  Тип expr1 сравним с типом expr2
$!  Либо expr1 является надтипом expr2, либо expr2 является надтипом expr1.

#L046 W1
Мы хотим привести значение типа t1 к типу t2, какое условие следует использовать:
$!  t1 :~: t2
$?  t1 :==: t2
$?  t1 :<=: t2
$?  t1 :=>: t2

#L047 W1
Укажите операцию объединения типов
$!  join(T1|T2|:|Tn)
$?  combine(T1|T2|:|Tn)
$?  meet(T1&T2&:&Tn)
$?  intersect(T1&T2&:&Tn)

#L048 W1
Укажите операцию пересечения типов 
$?  join(T1|T2|:|Tn)
$?  combine(T1|T2|:|Tn)
$!  meet(T1&T2&:&Tn)
$?  intersect(T1&T2&:&Tn)

#L049 W1
Где можно использовать операцию <.type> 
$?  в правилах вывода типов.
$?  в методах вывода типов.
$?  во всем остальном коде

#L050 W1
Укажите возможные виды антиквотирования:
$!  для дочерних узлов
$!  для ссылок
$!  для свойств
$!  для коллекций дочерних узлов
$?  для коллекций ссылок
$?  для коллекций свойств

#L051 W1
Для интеграции со средой разработки используетя язык:
$?  язык редактора
$!  язык плагинов
$?  язык интеншенов
$?  язык структуры

 

