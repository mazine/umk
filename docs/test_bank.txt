#L001 W1
Урезанная форма языка программирования, созданная 
специально для решения определенного вида проблем:
$?  Lisp
$!  язык предметной области
$?  языковой инструментарий
$?  yacc

#L002 W1
Язык предметной области это:
$?  Не тьюринг полный язык.
$!  Язык созданный для решения узкого класса проблем.
$?  Язык позволяющий не программистам писать программы.
$?  Язык имеющий абстрактный синтаксис.

#L003 W1
Общее название для такого стиля разработки программного 
обеспечения, который строится вокруг использования ряда 
языков, специфичных для данной предметной области. 
$?  объектно ориентированное программирование
$!  языкоориентированное программирование
$?  языковой инструментарий

#L004 W1
Общий термин для всех видов приложений, разработанных 
для поддержки языкоориентированного программирования.
$?  малые языки
$!  языковой инструментарий
$?  yacc
$?  Lisp

#L005 W1
Два языка предметной области:
$?  могут иметь общий абстрактный синтаксис 
$!  могут иметь общий конкретный синтаксис
$!  не могут иметь общий абстрактный синтаксис
$?  не могут иметь общий конкретный синтаксис

#L006 W1
Укажите языки предметной области:
$!  малые языки
$?  yacc
$!  конфигурационные файлы XML
$?  Lisp

#L007 W1
Конфигурационные файлы XML являются
$!  Являются внешним языком предметной области (DSL)
$?  Являются внутренним языки предметной области (DSL)
$?  Не являются языком предметной области (DSL)

#L008 W1
Создание внутренних языков предметной области (DSL) возможно с использованием
$!  Lisp
$!  Ruby
$?  XML
$?  Yacc

#L009 W1
Укажите преимущества внешних языков предметной области (DSL)
$!  Можно задавать произвольный синтаксис
$?  Существует хорошая интеграция с основным языком
$!  Код более удобен для чтения
$?  Существуют удобные инструменты для языка
$!  Не требует высокой квалификации

#L010 W1
Укажите преимущества внутренних языков предметной области (DSL)
$?  Можно задавать произвольный синтаксис
$!  Существует хорошая интеграция с основным языком
$?  Код более удобен для чтения
$!  Существуют удобные инструменты для языка
$?  Не требует высокой квалификации

#L011 W1
Укажите языки наиболее подходящие для создания внутренних (DSL)
$?  C
$?  C++
$?  Java
$?  C#
$!  Lisp
$!  Smalltalk 
$!  Ruby

#L012 W1
Укажите элементы языка полезные при создании DSL
$!  замыкания 
$!  макросы
$!  аннотации
$?  ООП
$?  типизация

#L013 W1
Укажите основные шаги создания новых DSL:
$!  Определить абстрактный синтаксис
$!  Выбрать редактор
$!  Создать генератор
$?  Определить ключевые слова языка
$?  Определить операторы языка
$?  Определить формат для хранениея программ

#L014 W1
Укажите базовые свойства языкового инструментария:
$!  Пользователи могут легко создавать новые языки
$!  Языки являются взаимноинтегрированными
$!  Главным источником информации является модель приложения
$?  Создание языка не требует описания абстрактоного синтаксиса

#L015 W1
Укажите базовые свойства языкового инструментария:
$!  Пользователи нового языка манипулируют им с помощью проекционного редактора
$!  Языковой инструментарий может работать, даже если абстрактная 
модель содержит неполную или противоречивую информацию
$?  Языковой инструментарий позволяет задавать языки графически

#L016 W1
Укажите составляющие нового DSL:
$!  схема
$!  редактор (редакторы)
$!  генератор (генераторы)
$?  модель (модели)
$?  проект

#L017 W1
Исходным представление программы для языкового инструментария является:
$?  текстовый файл
$!  абстрактное представление программы
$?  конкретный синтаксис
$?  конкретное представление программы

#L101 W1
Модель в системе MPS содержит:
$?  модули
$!  метаинформацию о модели
$?  исходные коды в текстовом виде
$!  корневые узлы

#L102 W1
Модуль в системе MPS содержит:
$!  модели
$?  исходные коды в текстовом виде
$!  вложенные модули
$!  метаинформацию о модуле

#L103 W1
В системе MPS существуют следующие виды модулей:
$!  решение
$?  модель
$!  язык
$!  генератор
$?  аспект языка
$!  пакет разработки

#L104 W1
Модели-заглушки (java stub models) в системе MPS:
$?  создаются вручную пользователем
$!  создаются автоматически
$?  компилируются системой MPS
$!  предназначены для интеграции с библиотеками Java

#L105 W1
В модуле языка обязательно наличие следующих аспектов:
$!  структура
$?  редактор
$?  плагин
$?  текстогенератор

#L106 W1
Корневые узлы в аспекте структура языка:
$!  концепт
$?  класс
$?  ячейка
$!  интерфейс концепта
$!  аннотация

#L107 W1
Концепт может:
$?  быть наследником нескольких концептов
$!  быть наследником одного концепта
$!  реализовывать несколько интерфейсов концепта
$!  реализовывать один интерфейс концепта
$!  не реализовывать ни одного интерфейса концепта

#L108 W1
Концепт, от которого наследуются все другие концепты:
$?  Concept
$!  BaseConcept
$?  AbstractConcept
$?  IConcept

#L109 W1
Объявление концепта состоит следующих частей:
$!  название концепта
$?  генератор концепта
$!  родительский концепт
$?  вид редактора концепта
$!  реализуемые интерфейсы концепта
$!  члены концепта

#L110 W1
Члены концепта включают в себя:
$!  свойства
$?  поля
$!  ссылки
$?  переменные
$!  дочерние узлы

#L111 W1
Аспект языка «Ограничения» определяет:
$?  методы и функции для концептов
$!  ограничения на структуру языка, не выражаемые структурным языком
$?  ограничения, накладываемые на наследование концептов

#L112 W1
Для концепта можно определить следующие ограничения:
$!  ограничения типа «может быть дочерним/родительским»
$?  ограничения на наседование концептов
$!  ограничения на ссылки
$!  ограничения на свойства
$!  область доступа по умолчанию

#L113 W1
Ограничение на свойство состоит из следующих элементов:
$!  метод получения значения
$!  метод присваивания значения
$?  метод получения области поиска
$!  метод проверки корректности значения

#L114 W1
Ограничение на ссылку состоит из следующих элементов:
$!  обработчик установки ссылки
$!  область поиска
$!  отображение ссылки
$?  метод проверки корректности ссылки

#L115 W1
Метод, возвращающий область поиска в аспекте «Ограничения»:
$!  может возвращать последовательность узлов
$?  может возвращать массив узлов
$!  может возвращать объект типа ISearchScope
$!  возвращает список узлов, на которые возможно ссылаться в данном контексте
#L116 W1
Если в концепте не определена область поиска для некоторый ссылки, используется область поиска по умолчанию для концепта, который является типом ссылки.
$!  Утверждение верно
$?  Утверждение ложно

#L117 W1
Виды методов в аспекте поведение
$!  абстрактные
$!  виртуальные
$?  расширенные
$!  статические
$?  синхронизированные

#L118 W1
В аспекте «Поведение» для концептов определяются следующие сущности:
$!  нестатические методы
$!  конструкторы
$?  поля
$?  свойства
$!  статические методы

#L119 W1
При вызове операции обращения к дочерним узлам для нулевого (null) узла произойдет следующее:
$?  будет брошено исключение NullPointerException
$?  будет брошено исключение AssertionError
$?  будет возвращена пустая последовательность узлов (содержащая 0 элементов)
$!  будет возвращено значение null

#L201 W1
Язык для представления конкретного синтаксиса языка в MPS называется:
$!  Язык редактора
$?  Язык структуры
$?  Язык конкретного синтаксиса
$?  Язык генератора

#L202 W1
Редактор MPS состоит из следующих частей.
!?  Ячеек
$?  Узлов
$?  Компонентов
$?  Элементов

#L203 W1
Для каждого концепта можно определить:
$?  Ровно один редактор
$!  Один или ни одного редактора
$?  Один или более редактор
$?  Любое количество редакторов

#L204 W1
Если для данного концепта не заданна структура редактора, 
то для узлов данного концепта.
$?  Структура редактора не будет определена
$?  Структура редактора будет браться из предка
$?  Структура редактора будет браться из интерфейса
$!  Структура редактора будет браться из предка или интерфейса

#L205 W1
Укажите название модели ячейки {name}
$!  Свойство
$?  Ребенок
$?  Ссылка
$?  Коллекция

#L206 W1
Укажите название модели ячейки %node%
$?  Свойство
$!  Ребенок
$?  Ссылка
$?  Коллекция

#L207 W1
Укажите название модели ячейки [-...-]
$?  Свойство
$?  Ребенок
$?  Ссылка
$!  Коллекция

#L208 W1
Укажите название модели ячейки (%node%->...)
$?  Свойство
$?  Ребенок
$!  Ссылка
$?  Коллекция


#L209 W1
Какая из данных моделей ячеек используется, чтобы избежать дублирования?
$!  Ячейки компоненты редактора
$?  Ячейка список детей
$?  Ячейка список детей
$?  Константная ячейка

#L210 W1
Для расположения ячеек в виде текста используется:
$!  indent layout
$?  horizontal layout
$?  vertical layout
$?  flow layout

#L211 W1
Какое количество предков может иметь таблица стилей:
$!  Не более одного
$?  Любое количество
$?  Ни одного

#L212 W1
Для задания действий происходящих при нажатии клавиш требуется использовать:
$!  Key map
$?  Key handler
$?  Action map

#L213 W1
Key map определяется для:
$?  Узла
$?  Редактора
$!  Ячейки

#L214 W1
Action map определяется для:
$?  Узла
$?  Редактора
$!  Ячейки

#L215 W1
Action map может переопределять:
$!  удаление
$!  правое преобразование
$?  левое преобразование
$?  добавление узла

#L216 W1
Для предопределения поведения при нажатии Delete требуется задать
$?  Key Map
$!  Action Map
$?  Key handler

#L217 W1
Для того что бы вызвать интеншен требуется 
$! нажать комбинацию клавиш Alt + Enter
$? нажать комбинацию клавиш Ctrl + Space
$! нажать на изображение лампочки
$? нажать на соотвествующий узел


#L218 W1
Выделение находится внутри позиции, которая позволяет подстановку концепта A. 
Какие подконцепты A не будут включены в меню автодополнениея:
$?  концепты, для которых не определен редактор
$?  концепты, для которых метод canSubstitute возвращает false
$!  абстрактные концепты
$!  концепты, для которых 'can be a child' (может быть ребенком) возвращает false

#L219 W1
"умная ссылка" называются концепты 
$?  если у концепта есть ссылка 0:1
$!   если у концепта есть ссылка 1:1
$?  если у концепта есть ссылка 
$?  если у концепта есть ребенок 0:1

#L301 W1
Часть языка, определяющая оперативную семантику концептов языка:
$!  Генератор
$?  Редактор
$?  Схема
$?  Модель

#L302 W1
Генерация кода в системе MPS происходит путем 
$!  трансформации моделей-в-модели
$?  трансформации моделей-в-текст
$?  трансформации текста-в-текст

#L303 W1
Генератор располагается 
$?  в отдельном руте
$?  в отдельной модели
$!  в отдельном модуле

#L304 W1
Генераторные модели отличаются от обычных 
$?  ничем
$!  наличием стереотипа "generator"
$?  расположением в модуле генератора

#L305 W1
Oграничения отображений ("mapping constraints") используются для 
$?  Возможности переопределять отображения
$!  Задания порядка генерации
$?  Ограничения действия отображений

#L306 W1
Трансформации при генерации определяются при помощи:
$!  правил генерации
$?  правил трансформации
$?  методов генерации

#L307 W1
Каждое правило генерации может содержать
$!  предпосылки
$!  следствие
$!  условие применимости
$?  название правила

#L308 W1
Макросы в шаблонах генерации реализованы при помощи:
$!  Аннотаций
$?  Ссылок
$?  Методов
$?  Концептов

#L309 W1
Существуют следующие виды макросов:
$!  макросы свойств
$!  макросы ссылок
$!  макросы узлов
$?  макросы концептов
$?  макросы корневых узлов

#L310 W1
Корневой шаблон трансформирует
$!  входной узел заданного концепта в корневой узел выходной модели
$?  корневой входной узел заданного концепта в корневой узел выходной модели
$?  корневой входной узел заданного концепта в узел выходной модели

#L311 W1
специальная конструкция языка генераторов "TemplateDeclaration" используется 
$? для генерации только корневых узлов
$! для генерации только некорневых узлов
$? для генерации любых узлов

#L401 W1
В системе MPS служить типом может:
$!  любой узел
$?  любой объект
$?  узел концепта Type
$?  объект класса Type

#L402 W1
Конструкция typeof
$?  возвращает Тип узла
$!  возвращает Типовою переменную соответствующую узлу
$?  проверяет соответствие типа

#L403 W1
Конструкция when concrete может использоваться
$?  где угодно
!?  в правилах вывода типов
!?  в методах помеченных специальной аннотацией

#L404 W1
Сильная подтиповость требуется для:
$!  вызова методов объекта
$!  доступа к полям объекта
$?  присваивания объекта
$?  передачи объекта в качестве параметра

#L405 W1
Тип n является слабым подтипом Integer укажите возможные конструкции
$?  n.toString();
$!  Object obj = n;
$!  method(n); // где метод принимает тип Object

#L405 W1
Для выражения Integer x = t; верно следующее:
$?  t имеет тип Integer
$?  тип t является сильным подтипом Integer
$?  тип t является слабым подтипом Integer
$?  тип t является сильным надтипом Integer
$!  тип t является слабым надтипом Integer

#L406 W1
Для выражения x instance of Type верно следующее:
$?  t имеет тип Type
$?  тип t является слабым подтипом Type
$?  тип t является слабым надтипом Type
$!  тип t и Type сравнимы

#L407 W1
Для выражения x.someMethod(), где someMethod определен в классе SomeClass
верно следующее:

$?  t имеет тип SomeClass
$?  тип t является сильным подтипом SomeClass
$?  тип t является слабым подтипом SomeClass
$!  тип t является сильным надтипом SomeClass
$!  тип t является слабым надтипом SomeClass

#L408 W1
Выражение typeof(expr1) :==: typeof(expr2) означает:
$!  Тип expr1 равен типу expr2
$?  Тип expr1 сравним с типом expr2
$?  Либо expr1 является надтипом expr2, либо expr2 является надтипом expr1.

#L409 W1
Выражение typeof(expr1) :~: typeof(expr2) означает:
$?  Тип expr1 равен типу expr2
$!  Тип expr1 сравним с типом expr2
$!  Либо expr1 является надтипом expr2, либо expr2 является надтипом expr1.

#L410 W1
Мы хотим привести значение типа t1 к типу t2, какое условие следует использовать:
$!  t1 :~: t2
$?  t1 :==: t2
$?  t1 :<=: t2
$?  t1 :=>: t2

#L411 W1
Укажите операцию объединения типов
$!  join(T1|T2|:|Tn)
$?  combine(T1|T2|:|Tn)
$?  meet(T1&T2&:&Tn)
$?  intersect(T1&T2&:&Tn)

#L412 W1
Укажите операцию пересечения типов 
$?  join(T1|T2|:|Tn)
$?  combine(T1|T2|:|Tn)
$!  meet(T1&T2&:&Tn)
$?  intersect(T1&T2&:&Tn)

#L413 W1
Где можно использовать операцию <.type> 
$?  в правилах вывода типов.
$?  в методах вывода типов.
$!  во всем остальном коде

#L414 W1
Укажите возможные виды антиквотирования:
$!  для дочерних узлов
$!  для ссылок
$!  для свойств
$!  для коллекций дочерних узлов
$?  для коллекций ссылок
$?  для коллекций свойств

#L415 W1
Выражение coerce используется для 
$! приведения типа к типу с заданной структурой 
$? получения типа выражения
$? проверки типа выражения


#L501 W1
Для интеграции со средой разработки используетя язык:
$?  язык редактора
$!  язык плагинов
$?  язык интеншенов
$?  язык структуры

#L502 W1
Укажите верную программу для выражения int a = f.executeMethod(p);
$? read f
   write a
   read p

$? write a
   read f
   read p

$! read p
   read f
   write a

#L503 W1
Укажите верную программу для выражения if (condition) {body}
$! code for condition 
    ifjump after end
    code for body
    label end 

$? code for condition
    ifjump after end
    code for body
    jump before condition
    label end 

$? code for body
    code for condition
    ifjump before body

#L504 W1
Укажите верную программу для выражения while (condition) {body}
$? code for condition 
    ifjump after end
    code for body
    label end 

$! code for condition
    ifjump after end
    code for body
    jump before condition
    label end 

$? code for body
    code for condition
    ifjump before body


#L505 W1
Укажите верную программу для выражения do {body} while (condition)
$? code for condition 
    ifjump after end
    code for body
    label end 

$? code for condition
    ifjump after end
    code for body
    jump before condition
    label end 

$! code for body
    code for condition
    ifjump before body


#L506 W1
Сейчас комбинации клавиш для действия A работают в тех местах, где 
$! A доступно из всплывающего меню
$? A находится в импортированной модели
$? A указано в какой-либо группе

#L507 W1
Действие будет A доступно при помощи комбинации клавиш alt+mnemonic во время
$? когда доступно всплывающее меню, содержащее A
$! A доступно из всплывающего меню
$? A указано в какой-либо группе

#L601 W1
Укажите к какому концепту baseLanguage относится это выражение
4 + 3
$!  Expression (выражение) 
$?  Statement (инструкция) 
$?  Type (тип) 
$?  IOperation (операция) 

#L602 W1
Укажите к какому концепту baseLanguage относится это выражение
if (obj != null) {
}
$?  Expression (выражение) 
$!  Statement (инструкция) 
$?  Type (тип) 
$?  IOperation (операция) 

#L603 W1
Укажите к какому концепту baseLanguage относится это выражение
string
$?  Expression (выражение) 
$?  Statement (инструкция) 
$!  Type (тип) 
$?  IOperation (операция) 

#L604 W1
Укажите к какому концепту baseLanguage относится это выражение
.toString()
$?  Expression (выражение) 
$?  Statement (инструкция) 
$?  Type (тип) 
$!  IOperation (операция) 


#L605 W1
В языке дат тип instant – представляет
$!  число миллисекунд прошедших с начала эпохи, 1970-01-01T00:00Z.
$?  дату и время с временной зоной.
$?  интервал времени измеренный в милисекундах.
$?  временного интервала определенного полями: секунды, минуты, и.т.д. 

#L606 W1
В языке дат тип datetime – представляет
$?  число миллисекунд прошедших с начала эпохи, 1970-01-01T00:00Z.
$!  дату и время с временной зоной.
$?  интервал времени измеренный в милисекундах.
$?  временного интервала определенного полями: секунды, минуты, и.т.д. 

#L607 W1
В языке дат тип duration – представляет
$?  число миллисекунд прошедших с начала эпохи, 1970-01-01T00:00Z.
$?  дату и время с временной зоной.
$!  интервал времени измеренный в милисекундах.
$?  временного интервала определенного полями: секунды, минуты, и.т.д. 

#L608 W1
В языке дат тип period – представляет
$?  число миллисекунд прошедших с начала эпохи, 1970-01-01T00:00Z.
$?  дату и время с временной зоной.
$?  интервал времени измеренный в милисекундах.
$!  временного интервала определенного полями: секунды, минуты, и.т.д. 

#L801 W1
Тип функции в языке замыканий параметризуется следующими сущностями:
$! список типов параметров
$? модификатор доступа
$! тип возвращаемого значения
$? синхронизированность

#L802 W1
Тип возвращаемого значения для литерала замыкания может быть получен из следующего:
$? последняя инструкция, если она не является ExpressionStatement
$! последняя инструкция, если она является ExpressionStatement
$! инструкция return с выражением
$! инструкция yield
$? первый параметр замыкания

#L803 W1
Если в литерале замыкания есть несколько инструкций yield с выражением типа int, то верны следующие утверждения:
$? тип возвращаемого значения у литерала - int
$! тип возвращаемого значения у литерала - sequence<int>
$? в литерале можно использовать инструкцию return только с выражением типа int
$! в литерале запрещено использовать инструкцию return

#L804 W1
Если f - переменная типа {int => void}, синтаксис вызова функции с параметром 1:
$? f(1)
$? f.run(1)
$! f.invoke(1)
$? f[1]

#L805 W1
В языке коллекций есть поддержка следующих структур данных:
$! множество
$! ассоциативный массив
$? очередь с приоритетами
$! список
$! последовательность
$? дерево интервалов

#L806 W1
Для получения подпоследовательности в языке коллекций есть следующие операции:
$! take
$! skip
$! cut
$! tail
$? subsequence
$! page
$? first

